---
output: pdf_document
header-includes: 
- \usepackage[utf8]{inputenc}
- \usepackage[T1]{fontenc}
- \usepackage[ngerman]{babel}
- \usepackage{amsmath,amssymb,amsthm}
- \usepackage{dsfont}
- \usepackage{listings}
- \usepackage{floatrow}
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- '\fancyhead[C,C]{Gruppe 5: Robin Baudisch, Merlin Kopfmann, Maximilian Neudert}'
- \fancyhead[L]{}
- \fancyhead[R]{}
- \fancyfoot[C,C]{\thepage}
- \renewcommand{\footrulewidth}{0.4pt}
---

<style type="text/css">
body{
  font-size: 12px;
}
h1 {
  font-size: 18px;
}
h1 {
  font-size: 14px;
}
h1 {
  font-size: 12px;
}
</style>

```{r global_options, include=FALSE}
knitr::opts_chunk$set(error=TRUE,        # Keep compiling upon error
                      collapse=TRUE,     # collapse by default
                      echo=TRUE,         # echo code by default
                      comment = "#>",    # change comment character
                      fig.width = 10,     # set figure width
                      out.width = "100%", # set width of displayed images
                      warning=TRUE,      # show R warnings
                      message=FALSE)     # show R messages
```

<!---** Hochschule Darmstadt | Studiengang Data Science | Sommersemester 2019 **--->

set.seed(42)

# Aufgabe 1

Datengenerierungsmodell.

```{r}
gendata = function (x, beta) {
  return (beta * log(x) + rnorm(length(x)))
}

gendf = function(n) {
  x = runif(n,1,5)
  y = gendata(x, 4)
  df = data.frame(x,y)
  return(df)
}
```

Berechnung der AIC.

```{r}
moldellin = function(n) {
  df = gendf(100)
  lmlin = lm(y~x, data = df)
  fdachlin = as.vector(lmlin$coefficients  %*% 3^seq(0,1))
  aiclin = AIC(lmlin)
  dfout = data.frame(AIC = aiclin)
  return(dfout)
}
moldelpoly = function(n) {
  df = gendf(100)
  lmpoly = lm(y~poly(x,5,raw=TRUE), data = df)
  fdachpoly = as.vector(lmpoly$coefficients  %*% 3^seq(0,5))
  aicpoly = AIC(lmpoly)
  dfout = data.frame(AIC = aicpoly)
  return(dfout)
}





# alllin <- matrix(NA,nrow=10000,ncol=6)
# colnames(alllin) <- c("fdach","y", "quadVor","EBias", "VarFDach","EQuadVor")
# allpol <- matrix(NA,nrow=10000,ncol=6)
# colnames(allpol) <- c("fdach","y", "quadVor","EBias", "VarFDach","EQuadVor")
# for (i in 1:10000){
#   x <- runif(100,1,5)
#   residuen <- rnorm(100,0,1)
#   b <- 4
#   y <- b*log(x)+residuen
#   lmlinear <- lm(y~x)
#   lmpoly <- lm(y~x+I(x^2)+I(x^3)+I(x^4)+I(x^5))
#   alllin[i,1] <- lmlinear$coefficients  %*% c(1,3)
#   allpol[i,1] <- lmpoly$coefficients %*% c(1,3,3^2,3^3,3^4,3^5)
#   
#   alllin[i,2] <- b*log(3)+rnorm(1)
#   allpol[i,2] <- alllin[i,2]
#   
#   alllin[i,3] <- (alllin[i,2]-alllin[i,1])^2
#   allpol[i,3] <- (allpol[i,2]-allpol[i,1])^2
# }
# alllin[,4] <- mean(alllin[,1])-4*log(3)
# allpol[,4] <- mean(allpol[,1])-4*log(3)
#   
# alllin[,5] <- var(alllin[,1])
# allpol[,5] <- var(allpol[,1])
# 
# 
# x3 <- rep(3,10000)
# y3 <- gendata(x3, 4)
# alllin[,6] <- mean((y3-alllin[,1])^2)
# allpol[,6] <- mean((y3-allpol[,1])^2)
```

Der AIC von linear ist größer als der von poly. Ein kleiner AIC steht für eine bessere Anpassungsgüte, da (p+1) positiver Strafterm.
